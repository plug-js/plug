import { TypeScriptHost } from '../typescript/host'
import { Files } from '../files'
import { extname } from 'path'
import { getCompilerOptions } from '../typescript/options'

import {
  createProgram,
  getPreEmitDiagnostics,
  CompilerOptions,
} from 'typescript'

import { Plug, install } from '../pipe'
import { checkDiagnostics } from '../typescript/diagnostic'
import { getAbsolutePath, getDirectoryPath, getRelativePath, isChild } from '../utils/paths'
import { Run } from '../run'

declare module '../pipe' {
  interface Pipe<P extends Pipe<P>> {
    compile: PlugExtension<P, typeof CompilePlug>
  }
}

const extensions = [ '.ts', '.d.ts', '.tsx' ] as readonly string[]
// const extensionsJs = [ '.ts', '.d.ts', '.tsx', '.js' ] as readonly string[]

interface ExtendedCompilerOptions extends CompilerOptions {
  /**
   * Indicates whether non-compilable files are passed through to the next
   * step, or ignored entirely and not available in the resulting file list.
   *
   * @default: false
   */
  passThrough?: boolean
}

export class CompilePlug implements Plug {
  #options?: ExtendedCompilerOptions
  #config?: string

  constructor(options?: ExtendedCompilerOptions)
  constructor(config?: string, options?: ExtendedCompilerOptions)
  constructor(first: string | CompilerOptions | undefined, extra?: ExtendedCompilerOptions) {
    const { config, options } =
      typeof first === 'string' ? { config: first, options: extra } :
      first === undefined ? { config: undefined, options: extra } :
      { config: undefined, options: first }

    this.#options = options
    this.#config = config
  }

  process(input: Files, run: Run): Files {
    const now = Date.now()

    // Read our compiler options and fail on error
    const host = new TypeScriptHost(input)
    const { options, diagnostics } = getCompilerOptions(input, this.#config, this.#options)
    checkDiagnostics(diagnostics, host, 'Error in TypeScript configuration')

    // For each file in the input list, check if we can compile it, or
    // (if specified) allow it to be passed through to the output
    const rootDir = getDirectoryPath(input.directory, options.rootDir)
    const outDir = getDirectoryPath(input.directory, options.outDir)

    const output = new Files(input.directory)
    const paths = input.list().map((file) => {
      const extension = extname(file.absolutePath).toLowerCase()
      if (extensions.includes(extension)) return file.absolutePath
      if (options.allowJs && (extension === '.js')) return file.absolutePath
      if (options.passThrough && isChild(rootDir, file.absolutePath)) {
        const relativePath = getRelativePath(rootDir, file.absolutePath)
        const passThroughPath = getAbsolutePath(outDir, relativePath)
        output.add(passThroughPath, file)
      }
    }).filter((path) => path) as string[]

    // Get our build file and create the master program
    const program = createProgram(paths, options, host, undefined, diagnostics)
    checkDiagnostics(getPreEmitDiagnostics(program), host, 'Error compiling')

    // Emit all files generated by our our compilation with their _original_
    // filename.ts file name in our virtual directory... they'll be handled by
    // our extension handler hacked above
    const result = program.emit(undefined, (fileName, contents, bom, oe, sources) => {
      let originalPath = undefined as string | undefined

      // For JS files, figure out the _original_ path of the ".ts" file by looking
      // into the source files associated with this output
      // istanbul ignore next - we only emit js, and always have source files
      if (extname(fileName) === '.js') {
        sources?.forEach(({ fileName }) => originalPath = input.get(fileName).absolutePath)
      }

      // Add the result of the compilation to our output files
      output.add(fileName, { contents, sourceMap: true, originalPath })
    })
    checkDiagnostics(result.diagnostics, host, 'Error emitting compilation')

    // Some logging
    const log = run.log(this)
    log.debug('Compliled', paths.length, 'in', Date.now() - now, 'ms')

    // All done!
    return output
  }
}

export const compile = install('compile', CompilePlug)
