import { TypeScriptHost } from '../typescript/host'
import { VirtualFileList } from '../files'
import { extname } from 'path'
import { getCompilerOptions } from '../typescript/options'

import {
  createProgram,
  getPreEmitDiagnostics,
  CompilerOptions,
} from 'typescript'

import { Plug, install } from '../pipe'
import { checkDiagnostics } from '../typescript/diagnostic'

declare module '../pipe' {
  interface Pipe<P extends Pipe<P>> {
    compile: PlugExtension<P, typeof CompilePlug>
  }
}

const extensions = [ '.ts', '.d.ts', '.tsx' ] as readonly string[]

export class CompilePlug implements Plug {
  #options?: CompilerOptions
  #config?: string

  constructor(options?: CompilerOptions)
  constructor(config?: string, options?: CompilerOptions)
  constructor(first: string | CompilerOptions | undefined, extra?: CompilerOptions) {
    const { config, options } =
      typeof first === 'string' ? { config: first, options: extra } :
      first === undefined ? { config: undefined, options: extra } :
      { config: undefined, options: first }

    this.#options = options
    this.#config = config
  }

  process(input: VirtualFileList): VirtualFileList {
    // Read our compiler options and fail on error
    const host = new TypeScriptHost(input)
    const { options, diagnostics } = getCompilerOptions(input, this.#config, this.#options)
    checkDiagnostics(diagnostics, host, 'Error in TypeScript configuration')

    // Choose files to compile, anyhing else gets cloned
    const output = new VirtualFileList(input.directoryPath)
    const allowed = options.allowJs ? [ '.js', ...extensions ] : extensions
    const paths = input.list().map((file) => {
      if (allowed.includes(extname(file.absolutePath))) return file.absolutePath
      // if (options.passThrough === true)
    }).filter((path) => path) as string[]

    // Get our build file and create the master program
    const program = createProgram(paths, options, host, undefined, diagnostics)
    checkDiagnostics(getPreEmitDiagnostics(program), host, 'Error compiling build file')

    // Create a virtual file list for our output

    // Emit all files generated by our our compilation with their _original_
    // filename.ts file name in our virtual directory... they'll be handled by
    // our extension handler hacked above
    const result = program.emit(undefined, (fileName, contents, bom, oe, sources) => {
      let originalPath = undefined as string | undefined

      // For JS files, figure out the _original_ path of the ".ts" file by looking
      // into the source files associated with this output
      // istanbul ignore next - we only emit js, and always have source files
      if (extname(fileName) === '.js') {
        sources?.forEach(({ fileName }) => originalPath = input.get(fileName).absolutePath)
      }

      // Add the result of the compilation to our output files
      output.add(fileName, { contents, sourceMap: true, originalPath })
    })
    checkDiagnostics(result.diagnostics, host, 'Error emitting build file compilation')

    // All done!
    return output
  }
}

export const compile = install('compile', CompilePlug)
