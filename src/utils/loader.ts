import Module from 'module'
import sourceMapSupport from 'source-map-support'
import { resolve, dirname, isAbsolute, sep } from 'path'
import { AbsolutePath, DirectoryPath, getDirectory, getDirectoryPath } from './paths'

// Install support for source maps, supporting dynamically compiled files
sourceMapSupport.install({ environment: 'node' })


// Add some types to "Module" so that we know what we're doing...
declare global {
  namespace NodeJS {
    interface Module {
      [marker]?: true // This identifies one of _our_ modules
      _compile: (contents: string, filename: string) => void
    }
  }
}

// Add some types to "typeof Module"
const cjs: typeof Module & {
  _load: (request: any, parent?: Module, isMain?: boolean) => any
  _cache: Record<string, Module>
} = Module as any

// Our marker to identify our modules
const marker = Symbol()

// Our content map, associating absolute paths with sources
const contentMap = new Map<AbsolutePath, string>()

// Emit a warning when circular dependencies are found
function emitCircularRequireWarning(file: string, from: string): void {
  process.emitWarning(`Circular dependency requiring "${file}" from "${from}"`)
}

// A proxy object used in lieu of module's exports warning about circular
// dependencies - the target here is always {} so we don't even check...
function createCircularWarningEmitter(file: string, from: string): object {
  return new Proxy({} as any, {
    getOwnPropertyDescriptor: () => void emitCircularRequireWarning(file, from),
    get: () => void emitCircularRequireWarning(file, from),
  })
}

// Preserve the old loader
const _loader = cjs._load

function findPaths(file: AbsolutePath): DirectoryPath[] {
  function walk(dir: DirectoryPath, paths: DirectoryPath[] = []): DirectoryPath[] {
    paths.push(getDirectoryPath(dir, 'node_modules'))
    const parent = getDirectory(dir)
    return parent === dir ? paths : walk(parent, paths)
  }
  return walk(getDirectory(file))
}

// Replace the Node JS loader with our own loader wrapper
cjs._load = function _load(request: any, parent?: Module, isMain?: boolean) {
  if ((typeof request === 'string') && (parent?.filename)) {
    // We can only load absolute paths (/foo/bar...) or _really_ relative (./foo/...)
    if (isAbsolute(request) || request.startsWith(`.${sep}`) || request.startsWith(`..${sep}`)) {
      // We have to search some files, as "require('./foo')" can result in requiring
      // the file itself, or "./foo.js" or "./foo/index.js" (or ".ts" for TypeScript)
      const files: AbsolutePath[] = [
        resolve(dirname(parent.filename), request) as AbsolutePath,
        resolve(dirname(parent.filename), request + '.ts') as AbsolutePath,
        resolve(dirname(parent.filename), request + '/index.ts') as AbsolutePath,
        resolve(dirname(parent.filename), request + '.js') as AbsolutePath,
        resolve(dirname(parent.filename), request + '/index.js') as AbsolutePath,
      ]

      // Let's check if we have (one by one) the file in our cache
      for (const file of files) {
        // No content? Next file to try!
        const content = contentMap.get(file)
        if (content === undefined) continue

        // Check caches, if we loaded this before...
        if (file in cjs._cache) {
          if (cjs._cache[file].loaded) return cjs._cache[file].exports
          return createCircularWarningEmitter(file, parent.filename)
        }

        // We have our content, create a new module and cache it
        const module = cjs._cache[file] = new Module(file, parent)
        module.exports = {}
        module.filename = file
        module.paths = findPaths(file)
        module[marker] = true

        // Compile our module using our contents
        module._compile(content, file)
        module.loaded = true

        // Return the module's exports
        return module.exports
      }
    }
  }

  // Nothing we can do but call the original loader
  return _loader.call(cjs, request, parent, isMain)
}

export function setupLoader(entries?: Map<AbsolutePath, string>): void {
  // Wipe any module generated by the loaded
  for (const module in cjs._cache) {
    if (cjs._cache[module][marker] === true) delete cjs._cache[module]
  }

  // Clear any previous content and if we have anything new, copy!
  contentMap.clear()
  entries?.forEach((content, path) => contentMap.set(path, content))
}
